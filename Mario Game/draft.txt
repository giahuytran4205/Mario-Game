#include "Item.hpp"
#include "Physics2D.hpp" 
#include "Collision.hpp"
#include <iostream>

// GreenMushroom implementation
GreenMushroom::GreenMushroom() {
    speed = 0.1f; // Movement speed
    physics.setVelocity({ speed, 0 });
    if (!texture.loadFromFile("green_mushroom.png")) {
        std::cerr << "Failed to load green_mushroom texture\n";
    }
    sprite.setTexture(texture);
}

void GreenMushroom::update(int deltaTime) {
    // Update physics
    physics.update();
    sprite.setPosition(physics.getVelocity().x * deltaTime, physics.getVelocity().y * deltaTime);
}

void GreenMushroom::onCollision() {
    // Reverse direction upon collision
    float currentSpeed = physics.getVelocity().x;
    physics.setVelocity({ -currentSpeed, 0 });
}

// OrangeMushroom implementation
OrangeMushroom::OrangeMushroom() {
    speed = 0.1f; // Movement speed
    physics.setVelocity({ speed, 0 });
    if (!texture.loadFromFile("orange_mushroom.png")) {
        std::cerr << "Failed to load orange_mushroom texture\n";
    }
    sprite.setTexture(texture);
}

void OrangeMushroom::update(int deltaTime) {
    // Update physics
    physics.update();
    sprite.setPosition(physics.getVelocity().x * deltaTime, physics.getVelocity().y * deltaTime);
}

void OrangeMushroom::onCollision() {
    // Reverse direction upon collision
    float currentSpeed = physics.getVelocity().x;
    physics.setVelocity({ -currentSpeed, 0 });
}

// TurtleShell implementation
TurtleShell::TurtleShell() {
    speed = 0; // Initially stationary
    isMoving = false;
    if (!texture.loadFromFile("turtle_shell.png")) {
        std::cerr << "Failed to load turtle_shell texture\n";
    }
    sprite.setTexture(texture);
}

void TurtleShell::update(int deltaTime) {
    // Only move if kicked
    if (isMoving) {
        physics.update();
        sprite.setPosition(physics.getVelocity().x * deltaTime, physics.getVelocity().y * deltaTime);
    }
}

void TurtleShell::onKick(float kickSpeed) {
    isMoving = true;
    physics.setVelocity({ kickSpeed, 0 });
}

void TurtleShell::onCollision() {
    // Reverse direction on collision
    float currentSpeed = physics.getVelocity().x;
    physics.setVelocity({ -currentSpeed, 0 });
}

// Flower implementation
Flower::Flower(float startY, float endY) : hiddenPosition(startY), finalPosition(endY) {
    if (!texture.loadFromFile("flower.png")) {
        std::cerr << "Failed to load flower texture\n";
    }
    sprite.setTexture(texture);
    sprite.setPosition(sprite.getPosition().x, hiddenPosition);
}

void Flower::update(int deltaTime) {
    // Move upward until fully revealed
    if (hiddenPosition > finalPosition) {
        float riseSpeed = 0.05f * deltaTime;
        hiddenPosition -= riseSpeed;
        sprite.setPosition(sprite.getPosition().x, hiddenPosition);
    }
}

void Flower::onCollision() {
    // No specific collision behavior
}

// Axe implementation
Axe::Axe() {
    if (!texture.loadFromFile("axe.png")) {
        std::cerr << "Failed to load axe texture\n";
    }
    sprite.setTexture(texture);
}

void Axe::update(int deltaTime) {
    // Stationary logic
}

void Axe::onCollision() {
    // No specific collision behavior
}

// Star implementation
Star::Star() {
    speed = 0.2f; // Movement speed
    physics.setVelocity({ speed, 0 });
    if (!texture.loadFromFile("star.png")) {
        std::cerr << "Failed to load star texture\n";
    }
    sprite.setTexture(texture);
}

void Star::update(int deltaTime) {
    // Simulate bouncing or reverse direction upon collision
    physics.update();
    sprite.setPosition(physics.getVelocity().x * deltaTime, physics.getVelocity().y * deltaTime);
}

void Star::onBounce() {
    // Add upward velocity for bouncing effect
    physics.bounce(-0.5f);
}

void Star::onCollision() {
    // Reverse horizontal direction
    float currentSpeed = physics.getVelocity().x;
    physics.setVelocity({ -currentSpeed, 0 });
}
